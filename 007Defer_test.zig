const expect = @import("std").testing.expect;

//defer - отложенное выполнение
//это ключевое слово откладывает выполнение до конца блока
// С блоком ознакомлены из функции
//Но стоит уточнить что блок можно использовать вроде как везде
//(требует уточнения)
// простой пример блока и defer

test "defer test" {
    var a: u16 = 0;
    defer a += 10;
    //В defer нельзя поместить return, в defer нельзя поместить try
    { //блок можно начать просто так
        const b: u16 = 10; //Это называется ЗАТЕНЕНИЕ
        //При переходе в новый блок, находящийся в другом
        //Когда переменная из внутреннего блока копирует имя внешней
        // И компилятор так делать не разрешает)
        //в том же Rust можно а тут он ругается, занятно))
        //Несмотря на то что затенить нельзя - можно напрямую обратиться к значению из внешнего блока
        a += 256;
        try expect(b == 10);
    }
    try expect(a == 256); //Потомучто в юлоке мы прибавили эти 256 
    //Хочу заметить, что при выходе из блока значение a станет тем что было до вхождения в блок

    //Так как мы вызвали defer, то оно переместит исполнение в конец блока
    // так что заканчиваем блок test
    try expect(a >= 256);
    //Тест будет завален так как defer выполнится после проверки
}

//Если defer много, то выполнятся они в обратном порядке

test "Много defer" {
    var a: u64 = 100;
    {
        defer a = a / 2; //Забавный момент
        //Компилятор поругался на то что я использовал /=
        //Тоесть для типа integer такое недопустимо что я понял из жалоб компилятора
        //Можете сами попробовать это как минимум занятно))
        //Я решил это поменяв тип на u64
        // Для него - работает
        //можете поставить тип i64 и работать перестанет
        //Во всяком случае на моей версии zig
        defer a += 20;
    }

    try expect(a == 60);
}

//Тут если бы defer выполнялись послежовательно, то
// 100 / 2 = 50
//50 + 20 = 70

//Но defer выполнтся в обратном порядке поэтому получаем

//100 + 20 = 120
//120/2 = 60
//Также в defer можно помещать ваши функции, библиотечные функции а не только мат операции

test "блок в defer" {
    var a: u64 = 100;
    { // Я понимаю что тут модно было просто расположить действия
        // без всяких блоков и defer. Но примера проще и умнее - не придумал
        defer {
            a /= 2;
            a += 20;
        }
    }
    try expect(a == 70);
}
