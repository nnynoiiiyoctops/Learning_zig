const expect = @import("std").testing.expect;

// Это - объявление функции, после объявления её можно использовать неограниченно много раз
fn FirstFunc() i64 {
    return 1024;
}

test "FirstFunc test" {
    //Синтаксис функций в большинстве языков 1
    // Ключевое слово которое указывает что это функция
    // в  C это не так, там указывается сперва возвращаемый тип
    //потом имя функции, по которому её можно вызвать и давайте покажу как ее вызывать
    const a: i64 = FirstFunc();

    try expect(a == 1024);
    // хочу заметить, что тип которые возвращает функция, должен соответствовать значению которому мы его присваиваем. Вот можете попробовать поменять тип на i32 и получить о*ибку компиляции
}

pub fn OwO() i64 {
    return 1025;
}
//Публичные функции могут быть использованы в другиз файлах
// Также есть inlime функции но о них - далее
test "OwO test" {
    const b: i64 = OwO();

    try expect(b == 1025);
}

inline fn UwU() i64 {
    return 1026;
}

test "UwU test" {
    const a: i64 = UwU();
    try expect(a == 1026);
}

//inlime - указание компилятору, что эта функция умещается в строчку и ее модно прям в код вставить без вызова функции
//Да, функция именно что вызывается и вызов функции - тоже ресурсы Но порой удобно написать функцию которая решает пример и сделать её inline

//А теперь рассмотрим передачу аргументов в функцию

fn QWQ(a: i64) i64 {
    return a + 1000; // код который выполняет функция называется ее телом
    // иногда тело функции могут называть сигнатурой функции
    //после слова fn и перед параметрами, тем что в скобкахт идёт имя функции
    //в скобках - её параметры,их можеь быть столькл сколько вам надо и каких угодно типов
}

test "qwqtst" {
    const b: i64 = QWQ(10); //вернёт 1010

    try expect(b == 1010);

    const c: i64 = QWQ(b); // имя переменной которую вы передаете в фуннкцию не обязано совпадать с тем которое вы писали при её обявлении. Вот тут мы получаем 2010
    try expect(c == 2010);
    // хочу щаметить, что b - константа, а мы меняем значениц, но также хлчу отметить, что в функцию передается значение переменной а не она сама. У переменной есть имя и значениеи чаще всего работа идет со значением, имя просто для идентефикации переменной
}

//рассмотрим случай когда параметров > 1

inline fn function(a: u8, b: u8) [10]u8 {
    return ([1]u8{a} ** 5) ++ ([1]u8{b} ** 5);
}

test "Сложная функция" {
    const a: u8 = 'a';
    const b: u8 = 'b';

    const array: [10]u8 = function(a, b);

    for (array[0..5]) |char| try expect(char == 'a');
    for (array[6..]) |char| try expect(char == 'b');
}
//ЗАНЯТНЫЙ МОМЕНТ
//Тут компиляция сорвалась. Суть - оказывается в случае с for указание от сих..сих идет включая 2ую границу
//А В СЛАЙСАХ - НЕТ ХАХАХАХАХА
