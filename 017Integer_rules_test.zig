//Странно что это идёт так поздно... Ну да ладно.
const expect = @import("std").testing.expect;

//Есть разные системы счисления и значения можно объявлять в разных системах счисления
test "Разные объявления одинаковых значений" {
    //Позволю себе наглость и перепишу с гайда
    const d_int: i32 = 999; //Десятичная система счисления
    try expect(d_int == 999);

    var h_int: i32 = 0xff; //16ричная система счисления Вообще все недесятичные системы счисления объвляются как
    //нельбуква 0x 0b 0o 12 2 и 8 ричные системы счисления.
    try expect(h_int == 0xff and h_int == 0xFF);
    h_int = 0x16AE; //Можно и F и f компилятор скушает и то и то
    try expect(h_int == 5806);
}
//Тут как и в Rust можно задать циферки красиво
//const one_billion: u64 = 1_000_000_000;
//const binary_mask: u64 = 0b1_1111_1111;
//const permissions: u64 = 0o7_5_5;
//const big_address: u64 = 0xFF80_0000_0000_0000;

test "integer widening" {
    //Преобразование. Хорошо что это есть потомучто если бы этого не было
    //То биты писались бы в начало числа от чего значение бы передавалось некорректнj
    const a: u8 = 250;
    const b: u16 = a;
    const c: u32 = b;
    try expect(c == a);
}

//Переполнение
//По дефолту - нельзя. Но есть отдельные операции которые позволяют сделать переполнение

// + не поддерживает переполнение
// +% поддерживает переполнение
// C переполнением работают только + - *. Операция деления работает несколько иначе. Деление - цикл вычитаний. Поэтому тут не происходит переполнения

// Для += тоже есть аналог +%=. Аналогично  с -= и *=, есть -%= *%=

test "Переполнение" {
    var a: u10 = 0;
    a -%= 1;

    try expect(a == 1023); //не 1024 потомучто 0 тоже учитывается
}
