const std = @import("std");
const expect = std.testing.expect;
//Импорт стандартной библиотеки.
//Да. Тут типы создаются через переменные и чаще всего константы

test "Constant test" {
    const Constant: bool = false;
    // const|var Имя_переменной[: Тип] = значение;
    //Тип можно опустить, но в таком случае компилятор определит его сам
    //И вам может непонравится какой тип компилятор даст переменной

    try expect(!Constant);
    // try используется для ловли ошибок. Если в секции провее try передалась ошибка (из функции или из блока)
    //try завершится с ошибкой. Чтобы этого избежать - следует использовать catch. Но обработка ошибок будет
    //затронута в Errors.zig

    var b: u8 = 27;
    try expect(b == 27);

    //Функция expect возвращает ошибку. Как видно по первым строкам - функция из стандартной бибилиотеки
    //Следовательно и ошибки возвращает предусмотренные стандартной библиотекой. В целом можно заменить
    //expect на if(expression) a else Error.RandomError; или вроде того. Но expect привычнее да и проще
    b += 50;
    try expect(b != 27);
}

test "as" {
    //функция @as и @TypeOf для работы с типами. Не как в Python или Go в которых для преобразования в
    //каждый тип - отдельная функция по типу int(). Удобно
    const testest: i16 = 10;
    const test2 = @as(u16, testest);

    try expect(@TypeOf(test2) == u16);
}

//Еще такой момент. После i и u можно указать любое кол-во бит на число вплоть до 65535. Но чаще хватает стандартных
//И всё же покажу пример

test "SUPER BIG" {
    const lim: u1000 = (1 << 1000) - 1; //Побитовый сдвиг влево и потом -1 чтобы взять максимальное значение
    const small_lim: u32 = (1 << 32) - 1;

    try expect(lim > small_lim);
}

//Вы можете запустить тест через команду
//zig test file_name.zig

//Дописываю позже
//Хотел поразглагольствовать и вот я тут
//В блоке с переменными стоит упомянуть и операции над ними

test "Operations" {
    const a: u8 = 0;
    const lim_a: u8 = a -% 1;
    //В операциях в которых может происходить переполнение
    //Есть процент
    //Или смотрите Runtime safity
    try expect(lim_a == 255);
}

test "Иные операции" {
    const a: i32 = 8;
    const b: i32 = 12;

    const summ: i32 = a + b;
    //Если вы хотите чтобы операция могла быть выполнена с переполнением
    //Можете использовать +%
    try expect(summ == 20);

    const razn: i32 = b - a;
    try expect(razn == 4);
    //В предыдущем тесте был показан оператор -%

    const mult: i32 = a * b;
    try expect(mult == 96);
    // *%аналогично

    const delt: i32 = b / a;
    try expect(delt == 1);
    //Нет, не 1 и куча значений после запятой
    //Дело в том, что при делении целых чисел( не float) результатом бцдет целое число

    const rznc: i32 = b % a;
    try expect(rznc == 4);
    //Остаток от деления

    const scbc: i32 = (2 + 2) * 2;
    try expect(scbc == 8);
    //Скобки вы будете испольщовать очень частоx
}
