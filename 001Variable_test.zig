const std = @import("std");
const expect = std.testing.expect;
//Импорт стандартной библиотеки.
//Да. Тут типы создаются через переменные и чаще всего константы

test "Constant test" {
    const Constant: bool = false;
    // const|var Имя_переменной[: Тип] = значение;
    //Тип можно опустить, но в таком случае компилятор определит его сам
    //И вам может непонравится какой тип компилятор даст переменной

    try expect(!Constant);
    // try используется для ловли ошибок. Если в секции провее try передалась ошибка (из функции или из блока)
    //try завершится с ошибкой. Чтобы этого избежать - следует использовать catch. Но обработка ошибок будет
    //затронута в Errors.zig

    var b: u8 = 27;
    try expect(b == 27);

    //Функция expect возвращает ошибку. Как видно по первым строкам - функция из стандартной бибилиотеки
    //Следовательно и ошибки возвращает предусмотренные стандартной библиотекой. В целом можно заменить
    //expect на if(expression) a else Error.RandomError; или вроде того. Но expect привычнее да и проще
    b += 50;
    try expect(b != 27);
}

test "as" {
    //функция @as и @TypeOf для работы с типами. Не как в Python или Go в которых для преобразования в
    //каждый тип - отдельная функция по типу int(). Удобно
    const testest: i16 = 10;
    const test2 = @as(u16, testest);

    try expect(@TypeOf(test2) == u16);
}

//Еще такой момент. После i и u можно указать любое кол-во бит на число вплоть до 65535. Но чаще хватает стандартных
//И всё же покажу пример

test "SUPER BIG" {
    const lim: u1000 = (1 << 1000) - 1; //Побитовый сдвиг влево и потом -1 чтобы взять максимальное значение
    const small_lim: u32 = (1 << 32) - 1;

    try expect(lim > small_lim);
}

//Вы можете запустить тест через команду
//zig test file_name.zig
